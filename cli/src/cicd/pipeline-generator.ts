/**
 * CI/CD Pipeline Generator
 * Generate CI/CD configurations for GitHub Actions, GitLab CI, etc.
 */

import * as fs from 'fs/promises';
import * as path from 'path';

export interface PipelineConfig {
  provider: 'github' | 'gitlab' | 'circleci' | 'jenkins';
  stages: PipelineStage[];
  environment: Record<string, string>;
  secrets: string[];
}

export interface PipelineStage {
  name: string;
  steps: PipelineStep[];
}

export interface PipelineStep {
  name: string;
  command: string;
  condition?: string;
}

export class PipelineGenerator {
  /**
   * Generate GitHub Actions workflow
   */
  generateGitHubActions(config: Partial<PipelineConfig>): string {
    const workflow = {
      name: 'CI/CD Pipeline',
      on: {
        push: {
          branches: ['main', 'develop']
        },
        pull_request: {
          branches: ['main']
        }
      },
      jobs: {
        test: {
          'runs-on': 'ubuntu-latest',
          steps: [
            {
              uses: 'actions/checkout@v4'
            },
            {
              name: 'Setup Node.js',
              uses: 'actions/setup-node@v4',
              with: {
                'node-version': '20',
                cache: 'npm'
              }
            },
            {
              name: 'Install dependencies',
              run: 'npm ci'
            },
            {
              name: 'Run linter',
              run: 'npm run lint'
            },
            {
              name: 'Run type check',
              run: 'npm run type-check'
            },
            {
              name: 'Run tests',
              run: 'npm test'
            },
            {
              name: 'Build',
              run: 'npm run build'
            }
          ]
        },
        deploy: {
          needs: 'test',
          'runs-on': 'ubuntu-latest',
          if: "github.ref == 'refs/heads/main'",
          steps: [
            {
              uses: 'actions/checkout@v4'
            },
            {
              name: 'Deploy to production',
              run: 'echo "Deploy step here"',
              env: {
                ...config.environment
              }
            }
          ]
        }
      }
    };

    return `# Generated by Z3BRA Quantum CLI
# Σₛ = dna::}{::lang

${this.toYAML(workflow)}`;
  }

  /**
   * Generate GitLab CI configuration
   */
  generateGitLabCI(config: Partial<PipelineConfig>): string {
    const pipeline = {
      stages: ['build', 'test', 'deploy'],

      variables: {
        NODE_VERSION: '20',
        ...config.environment
      },

      before_script: [
        'node --version',
        'npm --version'
      ],

      build: {
        stage: 'build',
        image: 'node:20-alpine',
        script: [
          'npm ci',
          'npm run build'
        ],
        artifacts: {
          paths: ['dist/'],
          expire_in: '1 day'
        }
      },

      test: {
        stage: 'test',
        image: 'node:20-alpine',
        script: [
          'npm ci',
          'npm run lint',
          'npm run type-check',
          'npm test'
        ],
        coverage: '/Lines\\s*:\\s*(\\d+\\.\\d+)%/'
      },

      deploy_production: {
        stage: 'deploy',
        image: 'node:20-alpine',
        script: [
          'echo "Deploying to production..."',
          'npm run deploy'
        ],
        only: ['main'],
        when: 'manual'
      }
    };

    return `# Generated by Z3BRA Quantum CLI
# Σₛ = dna::}{::lang

${this.toYAML(pipeline)}`;
  }

  /**
   * Generate Docker CI/CD workflow
   */
  generateDockerPipeline(): string {
    return `# Generated by Z3BRA Quantum CLI
name: Docker Build and Push

on:
  push:
    branches: ['main']
    tags: ['v*']

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: \${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: \${{ env.REGISTRY }}
          username: \${{ github.actor }}
          password: \${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: \${{ steps.meta.outputs.tags }}
          labels: \${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
`;
  }

  /**
   * Generate comprehensive test pipeline
   */
  generateTestPipeline(): string {
    return `# Generated by Z3BRA Quantum CLI
name: Comprehensive Testing

on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npm run test:unit
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/coverage-final.json

  integration-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npm run test:integration
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
          REDIS_URL: redis://localhost:6379

  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - name: Install Playwright
        run: npx playwright install --with-deps
      - run: npm run test:e2e
      - uses: actions/upload-artifact@v3
        if: always()
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30

  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npm audit
      - name: Run Snyk
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: \${{ secrets.SNYK_TOKEN }}
`;
  }

  /**
   * Generate deployment pipeline
   */
  generateDeploymentPipeline(platform: 'vercel' | 'netlify' | 'aws' | 'gcp'): string {
    const workflows: Record<string, string> = {
      vercel: `# Generated by Z3BRA Quantum CLI
name: Deploy to Vercel

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: amondnet/vercel-action@v25
        with:
          vercel-token: \${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: \${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: \${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
`,
      netlify: `# Generated by Z3BRA Quantum CLI
name: Deploy to Netlify

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm ci
      - run: npm run build
      - uses: netlify/actions/cli@master
        with:
          args: deploy --prod --dir=dist
        env:
          NETLIFY_SITE_ID: \${{ secrets.NETLIFY_SITE_ID }}
          NETLIFY_AUTH_TOKEN: \${{ secrets.NETLIFY_AUTH_TOKEN }}
`,
      aws: `# Generated by Z3BRA Quantum CLI
name: Deploy to AWS

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: \${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: \${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - run: npm ci
      - run: npm run build
      - run: aws s3 sync dist/ s3://\${{ secrets.S3_BUCKET }}
      - run: aws cloudfront create-invalidation --distribution-id \${{ secrets.CLOUDFRONT_ID }} --paths "/*"
`,
      gcp: `# Generated by Z3BRA Quantum CLI
name: Deploy to Google Cloud

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: google-github-actions/setup-gcloud@v1
        with:
          service_account_key: \${{ secrets.GCP_SA_KEY }}
          project_id: \${{ secrets.GCP_PROJECT_ID }}
      - run: npm ci
      - run: npm run build
      - run: gcloud app deploy
`
    };

    return workflows[platform] || workflows.vercel;
  }

  /**
   * Save pipeline to file
   */
  async savePipeline(content: string, provider: string, targetDir: string = '.'): Promise<string> {
    const paths: Record<string, string> = {
      github: '.github/workflows/ci-cd.yml',
      gitlab: '.gitlab-ci.yml',
      circleci: '.circleci/config.yml'
    };

    const filePath = path.join(targetDir, paths[provider] || paths.github);
    const dir = path.dirname(filePath);

    await fs.mkdir(dir, { recursive: true });
    await fs.writeFile(filePath, content, 'utf-8');

    return filePath;
  }

  /**
   * Simple YAML converter (basic implementation)
   */
  private toYAML(obj: any, indent: number = 0): string {
    const spaces = '  '.repeat(indent);
    let yaml = '';

    for (const [key, value] of Object.entries(obj)) {
      if (value === null || value === undefined) {
        continue;
      }

      if (Array.isArray(value)) {
        yaml += `${spaces}${key}:\n`;
        value.forEach(item => {
          if (typeof item === 'object') {
            yaml += `${spaces}-\n${this.toYAML(item, indent + 1)}`;
          } else {
            yaml += `${spaces}- ${item}\n`;
          }
        });
      } else if (typeof value === 'object') {
        yaml += `${spaces}${key}:\n${this.toYAML(value, indent + 1)}`;
      } else if (typeof value === 'string' && value.includes('\n')) {
        yaml += `${spaces}${key}: |\n${value.split('\n').map(l => `${spaces}  ${l}`).join('\n')}\n`;
      } else {
        const strValue = typeof value === 'string' && value.includes(':') ? `"${value}"` : value;
        yaml += `${spaces}${key}: ${strValue}\n`;
      }
    }

    return yaml;
  }
}
